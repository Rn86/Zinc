// sin
template <unsigned term>
inline double taylor_sine_term(double const& x) {
    return (power<term>(-1) / factorial<(2*term)+1>::value) * power<(2*term)+1>(x);
}

template<unsigned terms>
inline double taylor_sine(double const& x) {
    return taylor_sine_term<terms>(x) + // current term
           taylor_sine<terms-1>(x);     // rest of terms
}

template <>
inline double taylor_sine<0>(const double& x) {
    return taylor_sine_term<0>(x);
}

//===================================

//cos

template <unsigned term>
inline double taylor_cosine_term(double const& x) {
    return (power<term>(-1) / factorial<(2*term)>::value) * power<(2*term)>(x);
}

template<unsigned terms>
inline double taylor_cosine(double const& x) {
    return taylor_cosine_term<terms>(x) + // current term
           taylor_cosine<terms-1>(x);     // rest of terms
}

template <>
inline double taylor_cosine<0>(const double& x) {
    return taylor_cosine_term<0>(x);
}

//===================================

//e^x

template <unsigned term>
inline double taylor_e_term(double const& x) {
    return (factorial<(term)>::value) * power<(term)>(x);
}

template<unsigned terms>
inline double taylor_e(double const& x) {
    return taylor_e_term<terms>(x) + // current term
           taylor_e<terms-1>(x);     // rest of terms
}

template <>
inline double taylor_e<0>(const double& x) {
    return taylor_e_term<0>(x);
}

//===================================

//ln(x)

template <unsigned term>
inline double taylor_ln_term(double const& x) {
    return (power<term>(-1) / term * power<(term)>(-1+x);
}

template<unsigned terms>
inline double taylor_ln(double const& x) {
    return taylor_ln_term<terms>(x) + // current term
           taylor_ln<terms-1>(x);     // rest of terms
}

template <>
inline double taylor_ln<1>(const double& x) {
    return taylor_ln_term<1>(x);
}